# Standard Pattern for Persistent File Access with Android’s Document Picker

**Yes – Android provides a standard pattern using the Storage Access Framework (SAF) to persist access to user-selected files without duplicating them.** Instead of copying files into app storage, the typical approach is to use the system document picker (ACTION\_OPEN\_DOCUMENT) and **persist URI permissions** across app restarts. This leverages Android’s built-in **persistable URI grants** so your app can continue reading the content content:// URIs even after a reboot or process death[\[1\]](https://developer.android.com/training/data-storage/shared/documents-files#:~:text=When%20your%20app%20opens%20a,picker%20to%20find%20the%20files)[\[2\]](https://github.com/miguelpruivo/flutter_file_picker/issues/1825#:~:text=,and%20128%20on%20older%20versions). Below is how this pattern works and why it’s the recommended solution:

## Using Storage Access Framework with Persistable URI Permissions

Android differentiates between one-time file imports and long-term file access. The official guidance is:

* Use **ACTION\_GET\_CONTENT** if you plan to **import a copy of the data** into your app (read once and copy)[\[3\]](https://spot.pcc.edu/~mgoodman/developer.android.com/guide/topics/providers/document-provider.html#:~:text=,stored%20in%20a%20document%20provider). This suits cases where the app immediately duplicates the file (e.g. importing an image for editing).

* Use **ACTION\_OPEN\_DOCUMENT** if you want your app to have **ongoing, persistent access** to the file **without copying it**[\[3\]](https://spot.pcc.edu/~mgoodman/developer.android.com/guide/topics/providers/document-provider.html#:~:text=,stored%20in%20a%20document%20provider). This is ideal for media players or editors that work with the original file in place. In our case (VibeDeck’s audio tracks), we want long-term access to the user’s chosen audio file **without duplicating storage**, so ACTION\_OPEN\_DOCUMENT is the correct choice.

When you use ACTION\_OPEN\_DOCUMENT, Android’s SAF gives your app a **temporary URI permission** for the selected file (granting read access). However, by default this grant only lasts until your app process is killed or the device reboots[\[1\]](https://developer.android.com/training/data-storage/shared/documents-files#:~:text=When%20your%20app%20opens%20a,picker%20to%20find%20the%20files). That’s why the tracks play immediately after import, but fail after an app restart – the **URI permission was revoked** when the app restarted.

**To make the access persistent**, Android allows your app to “take” the URI permission grant so it persists beyond the current session. The standard steps are:

1. **Launch the document picker with persistable permission flags:** When firing the ACTION\_OPEN\_DOCUMENT intent, include the required flags. For example:

* Intent intent \= new Intent(Intent.ACTION\_OPEN\_DOCUMENT);  
  intent.addCategory(Intent.CATEGORY\_OPENABLE);  
  intent.setType("audio/\*");    
  // Allow persistent read permission  
  intent.addFlags(Intent.FLAG\_GRANT\_PERSISTABLE\_URI\_PERMISSION |   
                  Intent.FLAG\_GRANT\_READ\_URI\_PERMISSION);  
  startActivityForResult(intent, PICK\_AUDIO\_FILE);

* This ensures the system picker knows you want a persistable (long-term) grant, and read access to the URI[\[4\]](https://www.wochstudios.com/persistent-uri-permissions-in-android/#:~:text=%7D%20else%20,startActivityForResult%28intent%2C%20KITKAT_VALUE%29%3B). (Since VibeDeck only *reads* audio files, we include read permission; no need for write permission.)

2. **Take persistable permission on the returned URI:** In your onActivityResult (or equivalent callback) when the user selects a file, retrieve the content URI. **Immediately call** ContentResolver.takePersistableUriPermission(uri, flags) using the flags from the intent result[\[5\]](https://developer.android.com/training/data-storage/shared/documents-files#:~:text=Kotlin)[\[6\]](https://www.wochstudios.com/persistent-uri-permissions-in-android/#:~:text=int%20takeFlags%20%3D%20intent,takePersistableUriPermission%28fileUri%2CtakeFlags). For example:

* Uri audioUri \= resultData.getData();    
  final int takeFlags \= resultData.getFlags() & (Intent.FLAG\_GRANT\_READ\_URI\_PERMISSION   
                                                | Intent.FLAG\_GRANT\_WRITE\_URI\_PERMISSION);  
  getContentResolver().takePersistableUriPermission(audioUri, takeFlags);

* This *permanently secures* your app’s read access to that audioUri until you explicitly release it or the user uninstalls your app[\[1\]](https://developer.android.com/training/data-storage/shared/documents-files#:~:text=When%20your%20app%20opens%20a,picker%20to%20find%20the%20files)[\[5\]](https://developer.android.com/training/data-storage/shared/documents-files#:~:text=Kotlin). After this call, Android will **remember** that your app can access the URI even across device reboots.

3. **Store the URI for future use:** Save the content URI (as a string) in persistent storage (e.g. your SQLite database or SharedPreferences) for later retrieval[\[7\]](https://stackoverflow.com/questions/38955095/document-picker-keeps-showing-up-even-though-persistence-is-set-in-saf-storag#:~:text=If%20you%20are%20using%20,for%20a%20desktop%20OS%20program). The URI itself is stable and can be converted to a string and back – it serves as a persistent reference to the file. As CommonsWare notes, *“if you are using takePersistableUriPermission(), it is still your job to hold onto the Uri… saving the Uri somewhere… is not especially difficult.”*[\[7\]](https://stackoverflow.com/questions/38955095/document-picker-keeps-showing-up-even-though-persistence-is-set-in-saf-storag#:~:text=If%20you%20are%20using%20,for%20a%20desktop%20OS%20program). In practice, you might store each track’s content URI in the database along with its metadata.

4. **Use the persisted URI to access the file:** On subsequent app launches or whenever you need to play the audio, retrieve the stored URI string and convert it back to a Uri. Because you took persistable permission, you can now use ContentResolver to open the URI without any security exceptions. For example, use ContentResolver.openInputStream(uri) or set the MediaPlayer data source to that URI. The permission will still be in effect, so playback should succeed normally (no “permission denied” errors) even if the app was restarted[\[1\]](https://developer.android.com/training/data-storage/shared/documents-files#:~:text=When%20your%20app%20opens%20a,picker%20to%20find%20the%20files)[\[5\]](https://developer.android.com/training/data-storage/shared/documents-files#:~:text=Kotlin).

By following this pattern, the audio file **does not need to be copied** into app-private storage at all – the app continues to use the original content:// URI. Android’s design explicitly supports this use-case: *“Persistable URI grants remain Google’s recommended method for long-term access to user-selected files and folders.”*[\[2\]](https://github.com/miguelpruivo/flutter_file_picker/issues/1825#:~:text=,and%20128%20on%20older%20versions) In other words, the standard practice is to rely on SAF persistable permissions for offline file libraries rather than duplicating files.

## Why This is the Standard Solution

**User Experience:** This approach improves UX by not requiring the user to re-select files after every reboot. Once they pick a track, it stays playable in the app library permanently (until they delete it in-app). This aligns with modern Android’s storage philosophy – users explicitly grant access to specific files or directories via SAF, and the app maintains that access without blanket storage permissions.

**Avoiding Legacy Permissions:** Since VibeDeck targets Android 15 (SDK 35\) and must run on Android 7+, using SAF is crucial. On newer Android versions, you *cannot* freely read arbitrary files on external storage without special permissions. The alternative would be the broad MANAGE\_EXTERNAL\_STORAGE permission (or the legacy READ\_EXTERNAL\_STORAGE for pre-Android 13), which Google Play heavily discourages for most apps. Persisting a URI permission is a much more focused and privacy-friendly solution[\[8\]](https://github.com/miguelpruivo/flutter_file_picker/issues/1825#:~:text=Yes,ContentResolver.takePersistableUriPermission%28uri%2C%20flags). It avoids triggering Play Store red flags and keeps the app sandboxed except for the user-chosen files.

**No Storage Duplication:** The persistable URI method means you’re **not duplicating data**, which is exactly what we want. Users won’t have their storage wasted by duplicate audio files. Instead, VibeDeck plays the original file from its source location. Given the typical library size (20–50 tracks), using URI grants is well within Android’s limits (Android 11+ allows up to 512 persisted URI grants per app, and older versions allow 128[\[2\]](https://github.com/miguelpruivo/flutter_file_picker/issues/1825#:~:text=,and%20128%20on%20older%20versions)).

**Official and Widely-Used Pattern:** Many apps (especially media apps) follow this pattern. Android’s documentation and examples encourage it[\[1\]](https://developer.android.com/training/data-storage/shared/documents-files#:~:text=When%20your%20app%20opens%20a,picker%20to%20find%20the%20files)[\[5\]](https://developer.android.com/training/data-storage/shared/documents-files#:~:text=Kotlin). For instance, Google’s sample code shows taking persistable permissions so an app can reopen recent documents without reprompting the user[\[1\]](https://developer.android.com/training/data-storage/shared/documents-files#:~:text=When%20your%20app%20opens%20a,picker%20to%20find%20the%20files)[\[5\]](https://developer.android.com/training/data-storage/shared/documents-files#:~:text=Kotlin). A real-world example: a music app (“Infinite Soundboards”) implemented file picking by calling ACTION\_OPEN\_DOCUMENT for audio and then using takePersistableUriPermission – allowing it to play sounds across device restarts without copying files[\[4\]](https://www.wochstudios.com/persistent-uri-permissions-in-android/#:~:text=%7D%20else%20,startActivityForResult%28intent%2C%20KITKAT_VALUE%29%3B)[\[6\]](https://www.wochstudios.com/persistent-uri-permissions-in-android/#:~:text=int%20takeFlags%20%3D%20intent,takePersistableUriPermission%28fileUri%2CtakeFlags). This has become a standard approach on Android for apps that manage user-selected media offline.

## Caveats and Considerations

While persistable URI access is the recommended approach, be aware of a few nuances:

* **File Availability:** Persisting the URI permission doesn’t guarantee the file will always be present. If the user **moves or deletes the original file** (outside of your app), your stored URI becomes invalid[\[9\]](https://developer.android.com/training/data-storage/shared/documents-files#:~:text=Caution%3A%20Even%20after%20calling%20,regain%20access%20to%20the%20URI). In such cases, you’ll need to handle errors (e.g. catching a FileNotFoundException or SecurityException on open) and perhaps prompt the user to re-import or locate the file again. However, for one-time imports where users generally won’t alter the files afterward, this isn’t usually a big issue.

* **Vendor/Provider Quirks:** In general, ACTION\_OPEN\_DOCUMENT with persistable permissions is reliable across Android devices. However, there have been isolated reports of inconsistencies on certain OEMs. For example, a developer noted that on some Xiaomi devices, picking a file via a different intent (ACTION\_GET\_CONTENT) did not grant persistent permissions, leading to SecurityExceptions in background use[\[10\]](https://stackoverflow.com/questions/46684243/openinputstream-cause-securityexceptionpermission-denial-android-n#:~:text=). The solution in that case was to explicitly switch to ACTION\_OPEN\_DOCUMENT or copy the file as a fallback[\[11\]](https://stackoverflow.com/questions/46684243/openinputstream-cause-securityexceptionpermission-denial-android-n#:~:text=%40NabinBhandari%20is%20there%20any%20way,owned%20by%20a%20document%20provider)[\[12\]](https://stackoverflow.com/questions/46684243/openinputstream-cause-securityexceptionpermission-denial-android-n#:~:text=12). The takeaway is to make sure you **use the correct SAF intent** (as we’ve outlined) so that the URI is persistable. When using the official picker UI (ACTION\_OPEN\_DOCUMENT), the system should honor the persistable flag consistently. If takePersistableUriPermission() *were* to fail (e.g. due to a buggy provider), it would throw a SecurityException which you can catch[\[13\]](https://stackoverflow.com/questions/46684243/openinputstream-cause-securityexceptionpermission-denial-android-n#:~:text=I%20think%20it%27s%20because%20the,doesn%27t%20help). In practice, such failures are rare with the standard storage providers (Downloads, media store, external storage, etc.). Most modern Android devices/vendors adhere to the SAF contract.

* **Hybrid Approach (Persist \+ Copy):** Some apps implement a hybrid strategy: attempt to persist the URI permission, but if for some reason that permission can’t be secured or later gets lost, fall back to copying the file into app storage. This ensures reliability at the cost of complexity. The downside is exactly what you noted – it’s tricky to detect *when* a persisted permission has expired or failed. You would need to handle exceptions when accessing the URI after a restart and then recover by copying the file (which by then might require user action if the URI is no longer accessible). Given the **MVP scope** (no file moving/sync) and target audience (non-technical users), a confusing failure mode is best avoided. It’s usually better to get the approach right upfront (i.e. use persistable URIs properly) than to complicate the import logic with two code paths.

In summary, the **standard Android pattern** for your scenario is to **use the Storage Access Framework with persistable URI permissions**. This allows VibeDeck to keep playing imported tracks across app restarts **without duplicating files**. It’s the approach recommended by Google and used by many Android apps for long-term file access[\[2\]](https://github.com/miguelpruivo/flutter_file_picker/issues/1825#:~:text=,and%20128%20on%20older%20versions). By implementing takePersistableUriPermission on the content URIs from the document picker, you’ll satisfy the offline access requirement while respecting Android’s storage model. This gives a good balance of reliability and efficiency: the app remains fully offline and user-friendly, and the users’ storage isn’t needlessly consumed by duplicates.

**Sources:** Persistent URI permission usage in Android docs[\[1\]](https://developer.android.com/training/data-storage/shared/documents-files#:~:text=When%20your%20app%20opens%20a,picker%20to%20find%20the%20files)[\[5\]](https://developer.android.com/training/data-storage/shared/documents-files#:~:text=Kotlin), official SAF best practices[\[3\]](https://spot.pcc.edu/~mgoodman/developer.android.com/guide/topics/providers/document-provider.html#:~:text=,stored%20in%20a%20document%20provider), developer Q\&A on storing URIs and long-term access[\[7\]](https://stackoverflow.com/questions/38955095/document-picker-keeps-showing-up-even-though-persistence-is-set-in-saf-storag#:~:text=If%20you%20are%20using%20,for%20a%20desktop%20OS%20program), and modern Android storage guidance reaffirming persistable URIs as the recommended solution[\[2\]](https://github.com/miguelpruivo/flutter_file_picker/issues/1825#:~:text=,and%20128%20on%20older%20versions).

---

[\[1\]](https://developer.android.com/training/data-storage/shared/documents-files#:~:text=When%20your%20app%20opens%20a,picker%20to%20find%20the%20files) [\[5\]](https://developer.android.com/training/data-storage/shared/documents-files#:~:text=Kotlin) [\[9\]](https://developer.android.com/training/data-storage/shared/documents-files#:~:text=Caution%3A%20Even%20after%20calling%20,regain%20access%20to%20the%20URI) Access documents and other files from shared storage  |  App data and files  |  Android Developers

[https://developer.android.com/training/data-storage/shared/documents-files](https://developer.android.com/training/data-storage/shared/documents-files)

[\[2\]](https://github.com/miguelpruivo/flutter_file_picker/issues/1825#:~:text=,and%20128%20on%20older%20versions) [\[8\]](https://github.com/miguelpruivo/flutter_file_picker/issues/1825#:~:text=Yes,ContentResolver.takePersistableUriPermission%28uri%2C%20flags) Feature request – Support Storage-Access-Framework \*persistable\* URI grants on Android 10 \+ · Issue \#1825 · miguelpruivo/flutter\_file\_picker · GitHub

[https://github.com/miguelpruivo/flutter\_file\_picker/issues/1825](https://github.com/miguelpruivo/flutter_file_picker/issues/1825)

[\[3\]](https://spot.pcc.edu/~mgoodman/developer.android.com/guide/topics/providers/document-provider.html#:~:text=,stored%20in%20a%20document%20provider) Storage Access Framework | Android Developers

[https://spot.pcc.edu/\~mgoodman/developer.android.com/guide/topics/providers/document-provider.html](https://spot.pcc.edu/~mgoodman/developer.android.com/guide/topics/providers/document-provider.html)

[\[4\]](https://www.wochstudios.com/persistent-uri-permissions-in-android/#:~:text=%7D%20else%20,startActivityForResult%28intent%2C%20KITKAT_VALUE%29%3B) [\[6\]](https://www.wochstudios.com/persistent-uri-permissions-in-android/#:~:text=int%20takeFlags%20%3D%20intent,takePersistableUriPermission%28fileUri%2CtakeFlags) Persistent URI permissions in Android \- WOCH Studios

[https://www.wochstudios.com/persistent-uri-permissions-in-android/](https://www.wochstudios.com/persistent-uri-permissions-in-android/)

[\[7\]](https://stackoverflow.com/questions/38955095/document-picker-keeps-showing-up-even-though-persistence-is-set-in-saf-storag#:~:text=If%20you%20are%20using%20,for%20a%20desktop%20OS%20program) android \- Document-picker keeps showing up even though persistence is set (in SAF \- Storage Access Framework) \- Stack Overflow

[https://stackoverflow.com/questions/38955095/document-picker-keeps-showing-up-even-though-persistence-is-set-in-saf-storag](https://stackoverflow.com/questions/38955095/document-picker-keeps-showing-up-even-though-persistence-is-set-in-saf-storag)

[\[10\]](https://stackoverflow.com/questions/46684243/openinputstream-cause-securityexceptionpermission-denial-android-n#:~:text=) [\[11\]](https://stackoverflow.com/questions/46684243/openinputstream-cause-securityexceptionpermission-denial-android-n#:~:text=%40NabinBhandari%20is%20there%20any%20way,owned%20by%20a%20document%20provider) [\[12\]](https://stackoverflow.com/questions/46684243/openinputstream-cause-securityexceptionpermission-denial-android-n#:~:text=12) [\[13\]](https://stackoverflow.com/questions/46684243/openinputstream-cause-securityexceptionpermission-denial-android-n#:~:text=I%20think%20it%27s%20because%20the,doesn%27t%20help) openInputStream cause SecurityException:Permission Denial (Android N+) \- Stack Overflow

[https://stackoverflow.com/questions/46684243/openinputstream-cause-securityexceptionpermission-denial-android-n](https://stackoverflow.com/questions/46684243/openinputstream-cause-securityexceptionpermission-denial-android-n)